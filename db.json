{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/Anisina/source/css/blog-style.css","path":"css/blog-style.css","modified":1,"renderable":1},{"_id":"themes/Anisina/source/css/syntax.styl","path":"css/syntax.styl","modified":1,"renderable":1},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.eot","path":"fonts/glyphicons-halflings-regular.eot","modified":1,"renderable":1},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.woff2","path":"fonts/glyphicons-halflings-regular.woff2","modified":1,"renderable":1},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.ttf","path":"fonts/glyphicons-halflings-regular.ttf","modified":1,"renderable":1},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.woff","path":"fonts/glyphicons-halflings-regular.woff","modified":1,"renderable":1},{"_id":"themes/Anisina/source/js/blog.js","path":"js/blog.js","modified":1,"renderable":1},{"_id":"themes/Anisina/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":1,"renderable":1},{"_id":"themes/Anisina/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":1,"renderable":1},{"_id":"themes/Anisina/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1},{"_id":"themes/Anisina/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":1,"renderable":1},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.svg","path":"fonts/glyphicons-halflings-regular.svg","modified":1,"renderable":1},{"_id":"themes/Anisina/source/js/jquery.min.js","path":"js/jquery.min.js","modified":1,"renderable":1},{"_id":"themes/Anisina/source/js/jquery.js","path":"js/jquery.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"1e371583400f9b1fb9903e227c1a11f9de9a46da","modified":1513942810000},{"_id":"themes/Anisina/.DS_Store","hash":"be5d5c310d80b19adda21b95f325b96bd8b12f8f","modified":1513942810000},{"_id":"themes/Anisina/LICENSE","hash":"2b209f06bebeb2a8c2b7e187e436f3e1e1fbc8a7","modified":1513942810000},{"_id":"themes/Anisina/README.md","hash":"ebde4101f083169abf82f5d9aa6fa34959d5cf11","modified":1513942810000},{"_id":"themes/Anisina/_config.yml","hash":"3700280138e054753d9023f6fea60ccfdd701d6e","modified":1513942810000},{"_id":"themes/Anisina/package.json","hash":"12541fbf56f785e4f5d486a55b4939f3033f625b","modified":1513942810000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1513942810000},{"_id":"source/_posts/20171222.md","hash":"cfc4275a63823f03ad1ad9454d0a4a0b6ca0f3de","modified":1513943357000},{"_id":"source/_posts/hello-world.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1513942810000},{"_id":"source/_posts/socket编程.md","hash":"8dd425658cdbbddaae7f7d2c9fac1944662e07ec","modified":1514520479269},{"_id":"source/about/index.md","hash":"af87fcfa7998488a75721d7aec5bb3ac7d2489dd","modified":1513942810000},{"_id":"themes/Anisina/.idea/Anisina.iml","hash":"4240dabdc746a36bae8a56eeec04a3a3fc59d842","modified":1513942810000},{"_id":"themes/Anisina/.idea/modules.xml","hash":"6f81355dee5b607683bdbd56595a930fb4b83c8b","modified":1513942810000},{"_id":"themes/Anisina/.idea/vcs.xml","hash":"c92f3eb0ad1c70371e177a4d7d741f90af3f902c","modified":1513942810000},{"_id":"themes/Anisina/.idea/workspace.xml","hash":"7c5d920658041056cc34836371895677b507001c","modified":1513942810000},{"_id":"themes/Anisina/Screenshots/mobile-index.jpeg","hash":"cd75f77f5d865d42182e2233e354eeba9f114d98","modified":1513942810000},{"_id":"themes/Anisina/languages_to_be_added/de.yml","hash":"424a9c1e6ab69334d7873f6574da02ca960aa572","modified":1513942810000},{"_id":"themes/Anisina/languages_to_be_added/default.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1513942810000},{"_id":"themes/Anisina/languages_to_be_added/en.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1513942810000},{"_id":"themes/Anisina/languages_to_be_added/es.yml","hash":"cb4eeca0ed3768a77e0cd216300f2b2549628b1b","modified":1513942810000},{"_id":"themes/Anisina/languages_to_be_added/no.yml","hash":"8ca475a3b4f8efe6603030f0013aae39668230e1","modified":1513942810000},{"_id":"themes/Anisina/languages_to_be_added/pl.yml","hash":"de7eb5850ae65ba7638e907c805fea90617a988c","modified":1513942810000},{"_id":"themes/Anisina/languages_to_be_added/ru.yml","hash":"42df7afeb7a35dc46d272b7f4fb880a9d9ebcaa5","modified":1513942810000},{"_id":"themes/Anisina/languages_to_be_added/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1513942810000},{"_id":"themes/Anisina/languages_to_be_added/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1513942810000},{"_id":"themes/Anisina/layout/.DS_Store","hash":"f60423538e7d115abf8c86b365e85ad35b418b25","modified":1513942810000},{"_id":"themes/Anisina/layout/404.ejs","hash":"1fe05722bd1b32bbe0ae4e3e880866f935e0ae11","modified":1513942810000},{"_id":"themes/Anisina/layout/about.ejs","hash":"d409109a84aa5c032e1a230c973a91b293765176","modified":1513942810000},{"_id":"themes/Anisina/layout/archive.ejs","hash":"2f20b13b6a8c9ab17f38c0258ed58407866911d3","modified":1513942810000},{"_id":"themes/Anisina/layout/index.ejs","hash":"6820c011dc7b05d1a838d784e303b348b6426aee","modified":1513942810000},{"_id":"themes/Anisina/layout/index.ejs=","hash":"a94ac678f6b24a46824d45ec058b0ab2105a92c9","modified":1513942810000},{"_id":"themes/Anisina/layout/layout.ejs","hash":"b728827bf3ec55baf96a882032397e6c74c65f34","modified":1513942810000},{"_id":"themes/Anisina/layout/m_page.ejs","hash":"95bbc74aa6d10cddddd7a5cd5d2a06482f5ea173","modified":1513942810000},{"_id":"themes/Anisina/layout/page.ejs","hash":"d02762ca539942d8046175d90bdb9e1bb212db67","modified":1513942810000},{"_id":"themes/Anisina/layout/poetry.ejs","hash":"6c955d419050825e13d39c780d45aceafbf6552d","modified":1513942810000},{"_id":"themes/Anisina/layout/post.ejs","hash":"9427ac91b2bc36c339b528d9a569c038f0b18efa","modified":1513942810000},{"_id":"themes/Anisina/layout/tags.ejs","hash":"ff363455eeddfd389ecf6c5ab090408e1d2ef4e6","modified":1513942810000},{"_id":"themes/Anisina/layout/works.ejs","hash":"1df954e54098cc4845295836374abed870789dcd","modified":1513942810000},{"_id":"themes/Anisina/layout.bak/.DS_Store","hash":"f60423538e7d115abf8c86b365e85ad35b418b25","modified":1513942810000},{"_id":"themes/Anisina/layout.bak/404.ejs","hash":"1fe05722bd1b32bbe0ae4e3e880866f935e0ae11","modified":1513942810000},{"_id":"themes/Anisina/layout.bak/about.ejs","hash":"d409109a84aa5c032e1a230c973a91b293765176","modified":1513942810000},{"_id":"themes/Anisina/layout.bak/archive.ejs","hash":"2f20b13b6a8c9ab17f38c0258ed58407866911d3","modified":1513942810000},{"_id":"themes/Anisina/layout.bak/index.ejs","hash":"a94ac678f6b24a46824d45ec058b0ab2105a92c9","modified":1513942810000},{"_id":"themes/Anisina/layout.bak/layout.ejs","hash":"b728827bf3ec55baf96a882032397e6c74c65f34","modified":1513942810000},{"_id":"themes/Anisina/layout.bak/page.ejs","hash":"95bbc74aa6d10cddddd7a5cd5d2a06482f5ea173","modified":1513942810000},{"_id":"themes/Anisina/layout.bak/poetry.ejs","hash":"6c955d419050825e13d39c780d45aceafbf6552d","modified":1513942810000},{"_id":"themes/Anisina/layout.bak/post.ejs","hash":"9427ac91b2bc36c339b528d9a569c038f0b18efa","modified":1513942810000},{"_id":"themes/Anisina/layout.bak/tags.ejs","hash":"ff363455eeddfd389ecf6c5ab090408e1d2ef4e6","modified":1513942810000},{"_id":"themes/Anisina/layout.bak/works.ejs","hash":"1df954e54098cc4845295836374abed870789dcd","modified":1513942810000},{"_id":"themes/Anisina/.idea/inspectionProfiles/Project_Default.xml","hash":"cb98213afbdfab7620cd4b6ba8801035079b4ae5","modified":1513942810000},{"_id":"themes/Anisina/Screenshots/Anisina.png","hash":"146dd991f55a827a514259e20a51de1e9b07a13d","modified":1513942810000},{"_id":"themes/Anisina/layout/_partial/footer.ejs","hash":"5b54e8eb9eaff97ae52399283899e19c9680ab0c","modified":1513942810000},{"_id":"themes/Anisina/layout/_partial/head.ejs","hash":"4e0d96cac503d4e3a5b254d8b8175c392971ce38","modified":1513942810000},{"_id":"themes/Anisina/layout/_partial/nav.ejs","hash":"dbf4eb12802a4433abc2bf80d0eb3fcda5986d27","modified":1513942810000},{"_id":"themes/Anisina/layout/_partial/pagination.ejs","hash":"557d6bb069a1d48af49ae912994653f44b32a570","modified":1513942810000},{"_id":"themes/Anisina/layout.bak/_partial/footer.ejs","hash":"223a29b0154c2dcc5f8a6b6fee67ef78ead266ad","modified":1513942810000},{"_id":"themes/Anisina/layout.bak/_partial/head.ejs","hash":"4e0d96cac503d4e3a5b254d8b8175c392971ce38","modified":1513942810000},{"_id":"themes/Anisina/layout.bak/_partial/nav.ejs","hash":"dbf4eb12802a4433abc2bf80d0eb3fcda5986d27","modified":1513942810000},{"_id":"themes/Anisina/layout.bak/_partial/pagination.ejs","hash":"557d6bb069a1d48af49ae912994653f44b32a570","modified":1513942810000},{"_id":"themes/Anisina/source/css/blog-style.css","hash":"c6830e31138e412c2aa05228c4cd6035063fe651","modified":1513942810000},{"_id":"themes/Anisina/source/css/syntax.styl","hash":"f3f9ff0d1ebc4f7fa18d7e367b2ba2f0899adbd4","modified":1513942810000},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1513942810000},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1513942810000},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1513942810000},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1513942810000},{"_id":"themes/Anisina/source/js/blog.js","hash":"0f805c744ef8a48c0abdd9d204cfc19ee6cafc14","modified":1513942810000},{"_id":"themes/Anisina/source/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1513942810000},{"_id":"themes/Anisina/source/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1513942810000},{"_id":"themes/Anisina/source/js/totop.js","hash":"11ede60fccb7c763d6973f80efc78b47c0843746","modified":1513942810000},{"_id":"themes/Anisina/Screenshots/poetry-show.png","hash":"f5fdcd25026a87a0aafeebb1f19cdb3c0a81a666","modified":1513942810000},{"_id":"themes/Anisina/source/css/bootstrap.min.css","hash":"c5db932e115ff97af7b4512b947cde3ba2964db8","modified":1513942810000},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1513942810000},{"_id":"themes/Anisina/source/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1513942810000},{"_id":"themes/Anisina/layout/_partial/bak/footer.ejs","hash":"223a29b0154c2dcc5f8a6b6fee67ef78ead266ad","modified":1513942810000},{"_id":"themes/Anisina/Screenshots/mobile-post.jpeg","hash":"2081cdff23a9a8c185a48d9aabcc9dc8e77833ec","modified":1513942810000},{"_id":"themes/Anisina/source/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1513942810000},{"_id":"themes/Anisina/Screenshots/pc-index.png","hash":"b04094dac75cb656b4244c1dfaf246168a0f8926","modified":1513942810000},{"_id":"themes/Anisina/Screenshots/pc-post.png","hash":"cde56c0797b6ff8dd555fb1f8c3f9b21bceaa3be","modified":1513942810000}],"Category":[],"Data":[],"Page":[{"title":"about me","date":"2017-12-22T11:24:35.000Z","_content":"# 千代\n- 30岁 程序员\n- 居住在上海\n","source":"about/index.md","raw":"---\ntitle: about me\ndate: 2017-12-22 19:24:35\n---\n# 千代\n- 30岁 程序员\n- 居住在上海\n","updated":"2017-12-22T11:40:10.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjbreek6e0001f7c9o6h74ftn","content":"<h1 id=\"千代\"><a href=\"#千代\" class=\"headerlink\" title=\"千代\"></a>千代</h1><ul>\n<li>30岁 程序员</li>\n<li>居住在上海</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"千代\"><a href=\"#千代\" class=\"headerlink\" title=\"千代\"></a>千代</h1><ul>\n<li>30岁 程序员</li>\n<li>居住在上海</li>\n</ul>\n"}],"Post":[{"title":"fork()函数","date":"2017-12-22T11:49:00.000Z","_content":"# fork()函数\n```c\n#include <unistd.h>\n\npid_t fork(void)\n```\n- fork函数的返回值是pid。\n- fork函数调用一次，返回两次。在父进程中返回`子进程的pid`，在子进程中返回`0`。若出错返回`-1`。因此可通过`pid == 0`判断当前进程是否是子进程:\n```c\nint pid = fork();\nif(pid == 0){\n    printf(\"当前进程是子进程\");\n}else if(pid !=0 && pid != -1){\n    printf(\"当前进程是父进程, 子进程的pid:%d\\n\", pid);\n}else{\n    printf(\"获取进程错误\");\n}\n```\n- 每个子进程都有一个父进程。父进程有若干个子进程。获取父进程pid的方法：\n  ```c\n  int ppid = getppid();\n  printf(\"父进程的pid:%d\\n\", ppid);\n  ```\n- 父进程在fork之前打开的所有描述符都被子进程共享， 通常情况下都是父进程调用`accept`获取socket，然后子进程对socket读写。父进程负责socket的打开和关闭。\n- `fock()`函数的两个典型用法:\n  1. 一个进程创建自身的副本，由副本去处理自己的操作，父进程处理其他的操作。一般的网络服务器都采用这种方式。\n  2. 一个进程想要执行另外一个程序，先创建一个副本，然后由副本调用`exec()`将自己替换成新的程序。这是shell之类的程序的典型用法。\n","source":"_posts/20171222.md","raw":"---\ntitle: fork()函数\ndate: 2017-12-22 19:49:00\ntags:\n---\n# fork()函数\n```c\n#include <unistd.h>\n\npid_t fork(void)\n```\n- fork函数的返回值是pid。\n- fork函数调用一次，返回两次。在父进程中返回`子进程的pid`，在子进程中返回`0`。若出错返回`-1`。因此可通过`pid == 0`判断当前进程是否是子进程:\n```c\nint pid = fork();\nif(pid == 0){\n    printf(\"当前进程是子进程\");\n}else if(pid !=0 && pid != -1){\n    printf(\"当前进程是父进程, 子进程的pid:%d\\n\", pid);\n}else{\n    printf(\"获取进程错误\");\n}\n```\n- 每个子进程都有一个父进程。父进程有若干个子进程。获取父进程pid的方法：\n  ```c\n  int ppid = getppid();\n  printf(\"父进程的pid:%d\\n\", ppid);\n  ```\n- 父进程在fork之前打开的所有描述符都被子进程共享， 通常情况下都是父进程调用`accept`获取socket，然后子进程对socket读写。父进程负责socket的打开和关闭。\n- `fock()`函数的两个典型用法:\n  1. 一个进程创建自身的副本，由副本去处理自己的操作，父进程处理其他的操作。一般的网络服务器都采用这种方式。\n  2. 一个进程想要执行另外一个程序，先创建一个副本，然后由副本调用`exec()`将自己替换成新的程序。这是shell之类的程序的典型用法。\n","slug":"20171222","published":1,"updated":"2017-12-22T11:49:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbreek6a0000f7c96ft02b3j","content":"<h1 id=\"fork-函数\"><a href=\"#fork-函数\" class=\"headerlink\" title=\"fork()函数\"></a>fork()函数</h1><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">pid_t</span> fork(<span class=\"keyword\">void</span>)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>fork函数的返回值是pid。</li>\n<li><p>fork函数调用一次，返回两次。在父进程中返回<code>子进程的pid</code>，在子进程中返回<code>0</code>。若出错返回<code>-1</code>。因此可通过<code>pid == 0</code>判断当前进程是否是子进程:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> pid = fork();</span><br><span class=\"line\"><span class=\"keyword\">if</span>(pid == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"当前进程是子进程\"</span>);</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(pid !=<span class=\"number\">0</span> &amp;&amp; pid != <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"当前进程是父进程, 子进程的pid:%d\\n\"</span>, pid);</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"获取进程错误\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>每个子进程都有一个父进程。父进程有若干个子进程。获取父进程pid的方法：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> ppid = getppid();</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"父进程的pid:%d\\n\"</span>, ppid);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>父进程在fork之前打开的所有描述符都被子进程共享， 通常情况下都是父进程调用<code>accept</code>获取socket，然后子进程对socket读写。父进程负责socket的打开和关闭。</p>\n</li>\n<li><code>fock()</code>函数的两个典型用法:<ol>\n<li>一个进程创建自身的副本，由副本去处理自己的操作，父进程处理其他的操作。一般的网络服务器都采用这种方式。</li>\n<li>一个进程想要执行另外一个程序，先创建一个副本，然后由副本调用<code>exec()</code>将自己替换成新的程序。这是shell之类的程序的典型用法。</li>\n</ol>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"fork-函数\"><a href=\"#fork-函数\" class=\"headerlink\" title=\"fork()函数\"></a>fork()函数</h1><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">pid_t</span> fork(<span class=\"keyword\">void</span>)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>fork函数的返回值是pid。</li>\n<li><p>fork函数调用一次，返回两次。在父进程中返回<code>子进程的pid</code>，在子进程中返回<code>0</code>。若出错返回<code>-1</code>。因此可通过<code>pid == 0</code>判断当前进程是否是子进程:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> pid = fork();</span><br><span class=\"line\"><span class=\"keyword\">if</span>(pid == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"当前进程是子进程\"</span>);</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(pid !=<span class=\"number\">0</span> &amp;&amp; pid != <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"当前进程是父进程, 子进程的pid:%d\\n\"</span>, pid);</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"获取进程错误\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>每个子进程都有一个父进程。父进程有若干个子进程。获取父进程pid的方法：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> ppid = getppid();</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"父进程的pid:%d\\n\"</span>, ppid);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>父进程在fork之前打开的所有描述符都被子进程共享， 通常情况下都是父进程调用<code>accept</code>获取socket，然后子进程对socket读写。父进程负责socket的打开和关闭。</p>\n</li>\n<li><code>fock()</code>函数的两个典型用法:<ol>\n<li>一个进程创建自身的副本，由副本去处理自己的操作，父进程处理其他的操作。一般的网络服务器都采用这种方式。</li>\n<li>一个进程想要执行另外一个程序，先创建一个副本，然后由副本调用<code>exec()</code>将自己替换成新的程序。这是shell之类的程序的典型用法。</li>\n</ol>\n</li>\n</ul>\n"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2017-12-22T11:40:10.000Z","updated":"2017-12-22T11:40:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbreek6f0002f7c9y6500vct","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"title":"socket编程","date":"2017-12-28T08:47:57.000Z","_content":"# Unix Socket编程套路\n## 服务端步骤(回射服务器的例子)\n\n  `socket()` -> `bind()` -> `listen()` -> `accept()` -> `read()` -> `write()` -> `read()` -> `close()`\n\n## 客户端步骤(回射客户端的例子)\n\n  `socket()` -> `connect()` -> `write()` -> `read()` -> `close()`  \n\n## 常用函数解释\n- `int socket(int domain, int type, int protocol)` 三个参数\n    - 第一个参数表示使用的地址，一般是ipv4: AF_INET\n    - 第二个参数表示socket类型，tcp: SOCK_STREAM\n    - 第三个参数设置为0\n- `int bind(int sockfd, const struct sockaddr * serverAddr, socklen_t length)` 三个参数\n    - 第一个参数是socket\n    - 第二个参数是服务端地址，这个参数需要强转成(struct sockaddr \\*)类型\n    - 第三个参数是服务端地址长度\n- `int listen(int sockfd, int backlog)`\n    - 第一个参数是socket\n    - 第二个参数是backlog, [关于backlog的解释](http://man7.org/linux/man-pages/man2/listen.2.html)\n- `int accept(int sockfd, struct sockaddr * sockAddr, socklen_t * sockAddrLen)`\n    - 第一个参数是服务端socket描述符\n    - 第二个参数是传出参数，accept返回时传出客户端的地址和端口号\n    - 第三个参数是传入-传出参数，传入的是服务端提供的clientAddr缓冲区的大小，传出的是客户端地址结构的实际长度\n    - 出错返回-1\n- `ssize_t recv(int sockfd, const void *buff, size_t nbytes, int flags)`\n    - 第一个参数是客户端socket描述符\n    - 第二个参数是接收缓冲区\n    - 第三个参数是接收数据的长度??存疑\n    - 第四个参数一般设置为0\n- `ssize_t\tsend(int sockfd, const void * buff, size_t nbytes, int flags)`\n    - 第一个参数是客户端socket描述符\n    - 第二个参数是发送缓冲区\n    - 第三个参数是发送数据的长度??存疑\n    - 第四个参数一般设置为0\n\n\n## 代码示例\n- 服务端程序`server.c`\n\n```c\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#define SERVER_PORT 5555\n\nint main(){\n  int serverSocket, clientSocket;//声明服务端和客户端socket\n  serverSocket = socket(AF_INET, SOCK_STREAM, 0);//调用socket，获得服务端socket\n  //异常检测\n  if(serverSocket < 0){\n    perror(\"server socket error\");\n    exit(0);\n  }\n  struct sockaddr_in serverAddr;//声明服务端地址结构\n  bzero(&serverAddr, sizeof(serverAddr));//服务端地址结构填充\n  serverAddr.sin_family = AF_INET;//设置地址类型\n  serverAddr.sin_port = htons(SERVER_PORT);//设置地址端口,将端口转换成网络字节序\n  serverAddr.sin_addr.s_addr = htonl(INADDR_ANY);//INADDR_ANY代表0.0.0.0,转换成网络字节序\n  struct sockaddr_in clientAddr;//声明客户端地址结构\n  int clientAddrLen = sizeof(clientAddr);//客户端地址长度\n  char buffer[200];//读取数据用的缓冲区\n  int dataSize;//客户端返回的字节数\n  //调用bind,第二个参数要强转成(struct sockaddr *)类型\n  int checkBind = bind(serverSocket, (struct sockaddr *)&serverAddr, sizeof(serverAddr));\n  if(checkBind < 0){\n    perror(\"server bind error\");\n    exit(0);\n  }\n  int checkListen = listen(serverSocket, 5);//第二个参数是backlog，一般设置到30以下\n  if(checkListen < 0){\n    perror(\"server listen error\");\n    exit(0);\n  }\n  //开始主循环，接收客户端请求并处理请求\n  while(1){\n    printf(\"Listening on port: %d\\n\", SERVER_PORT);\n    //调用accept函数，进程进入阻塞状态\n    //accept返回客户端socket的文件描述符\n    //clientAddr是传出参数，accept返回时传出客户端的地址和端口号\n    //clientAddrLen是传入-传出参数，传入的是服务端提供的clientAddr缓冲区的大小，传出的是客户端地址结构的实际长度\n    //出错返回-1\n    clientSocket = accept(serverSocket, (struct sockaddr *)&clientAddr, (socklen_t*)&clientAddrLen);\n    if(clientSocket < 0){\n      perror(\"server accept error\");\n      continue;\n    }\n    //打印出客户端的ip和端口\n    printf(\"client ip: %s\\n\", inet_ntoa(clientAddr.sin_addr));\n    printf(\"client port: %d\\n\", htons(clientAddr.sin_port));\n    //开始读取客户端数据...\n    while(1){\n      dataSize = recv(clientSocket, buffer, 1024, 0);\n      if(dataSize < 0){\n        perror(\"server recv error\");\n        continue;\n      }else if(dataSize == 0){\n        //read返回0， 可关闭连接\n        break;\n      }\n      printf(\"dataSize大小：(%d)\\n\", dataSize);\n      buffer[dataSize] = '\\0';//设置缓冲区结尾为\\0\n      //如果客户端发送(quit\\r\\n)，结束传输数据，跳出循环\n      if(strcmp(buffer, \"quit\\r\\n\") == 0){\n        break;\n      }else if(strcmp(buffer, \"quit\") == 0){\n        break;\n      }\n      printf(\"%d data received, data is: (%s)\\n\", dataSize, buffer);\n      //把收到的数据发给客户端\n      send(clientSocket, buffer, dataSize, 0);\n    }\n  }\n  return 0;\n}\n\n```\n","source":"_posts/socket编程.md","raw":"---\ntitle: socket编程\ndate: 2017-12-28 16:47:57\ntags:\n---\n# Unix Socket编程套路\n## 服务端步骤(回射服务器的例子)\n\n  `socket()` -> `bind()` -> `listen()` -> `accept()` -> `read()` -> `write()` -> `read()` -> `close()`\n\n## 客户端步骤(回射客户端的例子)\n\n  `socket()` -> `connect()` -> `write()` -> `read()` -> `close()`  \n\n## 常用函数解释\n- `int socket(int domain, int type, int protocol)` 三个参数\n    - 第一个参数表示使用的地址，一般是ipv4: AF_INET\n    - 第二个参数表示socket类型，tcp: SOCK_STREAM\n    - 第三个参数设置为0\n- `int bind(int sockfd, const struct sockaddr * serverAddr, socklen_t length)` 三个参数\n    - 第一个参数是socket\n    - 第二个参数是服务端地址，这个参数需要强转成(struct sockaddr \\*)类型\n    - 第三个参数是服务端地址长度\n- `int listen(int sockfd, int backlog)`\n    - 第一个参数是socket\n    - 第二个参数是backlog, [关于backlog的解释](http://man7.org/linux/man-pages/man2/listen.2.html)\n- `int accept(int sockfd, struct sockaddr * sockAddr, socklen_t * sockAddrLen)`\n    - 第一个参数是服务端socket描述符\n    - 第二个参数是传出参数，accept返回时传出客户端的地址和端口号\n    - 第三个参数是传入-传出参数，传入的是服务端提供的clientAddr缓冲区的大小，传出的是客户端地址结构的实际长度\n    - 出错返回-1\n- `ssize_t recv(int sockfd, const void *buff, size_t nbytes, int flags)`\n    - 第一个参数是客户端socket描述符\n    - 第二个参数是接收缓冲区\n    - 第三个参数是接收数据的长度??存疑\n    - 第四个参数一般设置为0\n- `ssize_t\tsend(int sockfd, const void * buff, size_t nbytes, int flags)`\n    - 第一个参数是客户端socket描述符\n    - 第二个参数是发送缓冲区\n    - 第三个参数是发送数据的长度??存疑\n    - 第四个参数一般设置为0\n\n\n## 代码示例\n- 服务端程序`server.c`\n\n```c\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#define SERVER_PORT 5555\n\nint main(){\n  int serverSocket, clientSocket;//声明服务端和客户端socket\n  serverSocket = socket(AF_INET, SOCK_STREAM, 0);//调用socket，获得服务端socket\n  //异常检测\n  if(serverSocket < 0){\n    perror(\"server socket error\");\n    exit(0);\n  }\n  struct sockaddr_in serverAddr;//声明服务端地址结构\n  bzero(&serverAddr, sizeof(serverAddr));//服务端地址结构填充\n  serverAddr.sin_family = AF_INET;//设置地址类型\n  serverAddr.sin_port = htons(SERVER_PORT);//设置地址端口,将端口转换成网络字节序\n  serverAddr.sin_addr.s_addr = htonl(INADDR_ANY);//INADDR_ANY代表0.0.0.0,转换成网络字节序\n  struct sockaddr_in clientAddr;//声明客户端地址结构\n  int clientAddrLen = sizeof(clientAddr);//客户端地址长度\n  char buffer[200];//读取数据用的缓冲区\n  int dataSize;//客户端返回的字节数\n  //调用bind,第二个参数要强转成(struct sockaddr *)类型\n  int checkBind = bind(serverSocket, (struct sockaddr *)&serverAddr, sizeof(serverAddr));\n  if(checkBind < 0){\n    perror(\"server bind error\");\n    exit(0);\n  }\n  int checkListen = listen(serverSocket, 5);//第二个参数是backlog，一般设置到30以下\n  if(checkListen < 0){\n    perror(\"server listen error\");\n    exit(0);\n  }\n  //开始主循环，接收客户端请求并处理请求\n  while(1){\n    printf(\"Listening on port: %d\\n\", SERVER_PORT);\n    //调用accept函数，进程进入阻塞状态\n    //accept返回客户端socket的文件描述符\n    //clientAddr是传出参数，accept返回时传出客户端的地址和端口号\n    //clientAddrLen是传入-传出参数，传入的是服务端提供的clientAddr缓冲区的大小，传出的是客户端地址结构的实际长度\n    //出错返回-1\n    clientSocket = accept(serverSocket, (struct sockaddr *)&clientAddr, (socklen_t*)&clientAddrLen);\n    if(clientSocket < 0){\n      perror(\"server accept error\");\n      continue;\n    }\n    //打印出客户端的ip和端口\n    printf(\"client ip: %s\\n\", inet_ntoa(clientAddr.sin_addr));\n    printf(\"client port: %d\\n\", htons(clientAddr.sin_port));\n    //开始读取客户端数据...\n    while(1){\n      dataSize = recv(clientSocket, buffer, 1024, 0);\n      if(dataSize < 0){\n        perror(\"server recv error\");\n        continue;\n      }else if(dataSize == 0){\n        //read返回0， 可关闭连接\n        break;\n      }\n      printf(\"dataSize大小：(%d)\\n\", dataSize);\n      buffer[dataSize] = '\\0';//设置缓冲区结尾为\\0\n      //如果客户端发送(quit\\r\\n)，结束传输数据，跳出循环\n      if(strcmp(buffer, \"quit\\r\\n\") == 0){\n        break;\n      }else if(strcmp(buffer, \"quit\") == 0){\n        break;\n      }\n      printf(\"%d data received, data is: (%s)\\n\", dataSize, buffer);\n      //把收到的数据发给客户端\n      send(clientSocket, buffer, dataSize, 0);\n    }\n  }\n  return 0;\n}\n\n```\n","slug":"socket编程","published":1,"updated":"2017-12-29T04:07:59.269Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbreek6h0003f7c9avnrk2un","content":"<h1 id=\"Unix-Socket编程套路\"><a href=\"#Unix-Socket编程套路\" class=\"headerlink\" title=\"Unix Socket编程套路\"></a>Unix Socket编程套路</h1><h2 id=\"服务端步骤-回射服务器的例子\"><a href=\"#服务端步骤-回射服务器的例子\" class=\"headerlink\" title=\"服务端步骤(回射服务器的例子)\"></a>服务端步骤(回射服务器的例子)</h2><p>  <code>socket()</code> -&gt; <code>bind()</code> -&gt; <code>listen()</code> -&gt; <code>accept()</code> -&gt; <code>read()</code> -&gt; <code>write()</code> -&gt; <code>read()</code> -&gt; <code>close()</code></p>\n<h2 id=\"客户端步骤-回射客户端的例子\"><a href=\"#客户端步骤-回射客户端的例子\" class=\"headerlink\" title=\"客户端步骤(回射客户端的例子)\"></a>客户端步骤(回射客户端的例子)</h2><p>  <code>socket()</code> -&gt; <code>connect()</code> -&gt; <code>write()</code> -&gt; <code>read()</code> -&gt; <code>close()</code>  </p>\n<h2 id=\"常用函数解释\"><a href=\"#常用函数解释\" class=\"headerlink\" title=\"常用函数解释\"></a>常用函数解释</h2><ul>\n<li><code>int socket(int domain, int type, int protocol)</code> 三个参数<ul>\n<li>第一个参数表示使用的地址，一般是ipv4: AF_INET</li>\n<li>第二个参数表示socket类型，tcp: SOCK_STREAM</li>\n<li>第三个参数设置为0</li>\n</ul>\n</li>\n<li><code>int bind(int sockfd, const struct sockaddr * serverAddr, socklen_t length)</code> 三个参数<ul>\n<li>第一个参数是socket</li>\n<li>第二个参数是服务端地址，这个参数需要强转成(struct sockaddr *)类型</li>\n<li>第三个参数是服务端地址长度</li>\n</ul>\n</li>\n<li><code>int listen(int sockfd, int backlog)</code><ul>\n<li>第一个参数是socket</li>\n<li>第二个参数是backlog, <a href=\"http://man7.org/linux/man-pages/man2/listen.2.html\" target=\"_blank\" rel=\"noopener\">关于backlog的解释</a></li>\n</ul>\n</li>\n<li><code>int accept(int sockfd, struct sockaddr * sockAddr, socklen_t * sockAddrLen)</code><ul>\n<li>第一个参数是服务端socket描述符</li>\n<li>第二个参数是传出参数，accept返回时传出客户端的地址和端口号</li>\n<li>第三个参数是传入-传出参数，传入的是服务端提供的clientAddr缓冲区的大小，传出的是客户端地址结构的实际长度</li>\n<li>出错返回-1</li>\n</ul>\n</li>\n<li><code>ssize_t recv(int sockfd, const void *buff, size_t nbytes, int flags)</code><ul>\n<li>第一个参数是客户端socket描述符</li>\n<li>第二个参数是接收缓冲区</li>\n<li>第三个参数是接收数据的长度??存疑</li>\n<li>第四个参数一般设置为0</li>\n</ul>\n</li>\n<li><code>ssize_t    send(int sockfd, const void * buff, size_t nbytes, int flags)</code><ul>\n<li>第一个参数是客户端socket描述符</li>\n<li>第二个参数是发送缓冲区</li>\n<li>第三个参数是发送数据的长度??存疑</li>\n<li>第四个参数一般设置为0</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"代码示例\"><a href=\"#代码示例\" class=\"headerlink\" title=\"代码示例\"></a>代码示例</h2><ul>\n<li>服务端程序<code>server.c</code></li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;errno.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netdb.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netinet/in.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;arpa/inet.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SERVER_PORT 5555</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> serverSocket, clientSocket;<span class=\"comment\">//声明服务端和客户端socket</span></span><br><span class=\"line\">  serverSocket = socket(AF_INET, SOCK_STREAM, <span class=\"number\">0</span>);<span class=\"comment\">//调用socket，获得服务端socket</span></span><br><span class=\"line\">  <span class=\"comment\">//异常检测</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(serverSocket &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    perror(<span class=\"string\">\"server socket error\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">serverAddr</span>;</span><span class=\"comment\">//声明服务端地址结构</span></span><br><span class=\"line\">  bzero(&amp;serverAddr, <span class=\"keyword\">sizeof</span>(serverAddr));<span class=\"comment\">//服务端地址结构填充</span></span><br><span class=\"line\">  serverAddr.sin_family = AF_INET;<span class=\"comment\">//设置地址类型</span></span><br><span class=\"line\">  serverAddr.sin_port = htons(SERVER_PORT);<span class=\"comment\">//设置地址端口,将端口转换成网络字节序</span></span><br><span class=\"line\">  serverAddr.sin_addr.s_addr = htonl(INADDR_ANY);<span class=\"comment\">//INADDR_ANY代表0.0.0.0,转换成网络字节序</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">clientAddr</span>;</span><span class=\"comment\">//声明客户端地址结构</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> clientAddrLen = <span class=\"keyword\">sizeof</span>(clientAddr);<span class=\"comment\">//客户端地址长度</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> buffer[<span class=\"number\">200</span>];<span class=\"comment\">//读取数据用的缓冲区</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> dataSize;<span class=\"comment\">//客户端返回的字节数</span></span><br><span class=\"line\">  <span class=\"comment\">//调用bind,第二个参数要强转成(struct sockaddr *)类型</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> checkBind = bind(serverSocket, (struct sockaddr *)&amp;serverAddr, <span class=\"keyword\">sizeof</span>(serverAddr));</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(checkBind &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    perror(<span class=\"string\">\"server bind error\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> checkListen = listen(serverSocket, <span class=\"number\">5</span>);<span class=\"comment\">//第二个参数是backlog，一般设置到30以下</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(checkListen &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    perror(<span class=\"string\">\"server listen error\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//开始主循环，接收客户端请求并处理请求</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Listening on port: %d\\n\"</span>, SERVER_PORT);</span><br><span class=\"line\">    <span class=\"comment\">//调用accept函数，进程进入阻塞状态</span></span><br><span class=\"line\">    <span class=\"comment\">//accept返回客户端socket的文件描述符</span></span><br><span class=\"line\">    <span class=\"comment\">//clientAddr是传出参数，accept返回时传出客户端的地址和端口号</span></span><br><span class=\"line\">    <span class=\"comment\">//clientAddrLen是传入-传出参数，传入的是服务端提供的clientAddr缓冲区的大小，传出的是客户端地址结构的实际长度</span></span><br><span class=\"line\">    <span class=\"comment\">//出错返回-1</span></span><br><span class=\"line\">    clientSocket = accept(serverSocket, (struct sockaddr *)&amp;clientAddr, (<span class=\"keyword\">socklen_t</span>*)&amp;clientAddrLen);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(clientSocket &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">      perror(<span class=\"string\">\"server accept error\"</span>);</span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//打印出客户端的ip和端口</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"client ip: %s\\n\"</span>, inet_ntoa(clientAddr.sin_addr));</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"client port: %d\\n\"</span>, htons(clientAddr.sin_port));</span><br><span class=\"line\">    <span class=\"comment\">//开始读取客户端数据...</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">      dataSize = recv(clientSocket, buffer, <span class=\"number\">1024</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(dataSize &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        perror(<span class=\"string\">\"server recv error\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">      &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(dataSize == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//read返回0， 可关闭连接</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">printf</span>(<span class=\"string\">\"dataSize大小：(%d)\\n\"</span>, dataSize);</span><br><span class=\"line\">      buffer[dataSize] = <span class=\"string\">'\\0'</span>;<span class=\"comment\">//设置缓冲区结尾为\\0</span></span><br><span class=\"line\">      <span class=\"comment\">//如果客户端发送(quit\\r\\n)，结束传输数据，跳出循环</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(<span class=\"built_in\">strcmp</span>(buffer, <span class=\"string\">\"quit\\r\\n\"</span>) == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"built_in\">strcmp</span>(buffer, <span class=\"string\">\"quit\"</span>) == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d data received, data is: (%s)\\n\"</span>, dataSize, buffer);</span><br><span class=\"line\">      <span class=\"comment\">//把收到的数据发给客户端</span></span><br><span class=\"line\">      send(clientSocket, buffer, dataSize, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Unix-Socket编程套路\"><a href=\"#Unix-Socket编程套路\" class=\"headerlink\" title=\"Unix Socket编程套路\"></a>Unix Socket编程套路</h1><h2 id=\"服务端步骤-回射服务器的例子\"><a href=\"#服务端步骤-回射服务器的例子\" class=\"headerlink\" title=\"服务端步骤(回射服务器的例子)\"></a>服务端步骤(回射服务器的例子)</h2><p>  <code>socket()</code> -&gt; <code>bind()</code> -&gt; <code>listen()</code> -&gt; <code>accept()</code> -&gt; <code>read()</code> -&gt; <code>write()</code> -&gt; <code>read()</code> -&gt; <code>close()</code></p>\n<h2 id=\"客户端步骤-回射客户端的例子\"><a href=\"#客户端步骤-回射客户端的例子\" class=\"headerlink\" title=\"客户端步骤(回射客户端的例子)\"></a>客户端步骤(回射客户端的例子)</h2><p>  <code>socket()</code> -&gt; <code>connect()</code> -&gt; <code>write()</code> -&gt; <code>read()</code> -&gt; <code>close()</code>  </p>\n<h2 id=\"常用函数解释\"><a href=\"#常用函数解释\" class=\"headerlink\" title=\"常用函数解释\"></a>常用函数解释</h2><ul>\n<li><code>int socket(int domain, int type, int protocol)</code> 三个参数<ul>\n<li>第一个参数表示使用的地址，一般是ipv4: AF_INET</li>\n<li>第二个参数表示socket类型，tcp: SOCK_STREAM</li>\n<li>第三个参数设置为0</li>\n</ul>\n</li>\n<li><code>int bind(int sockfd, const struct sockaddr * serverAddr, socklen_t length)</code> 三个参数<ul>\n<li>第一个参数是socket</li>\n<li>第二个参数是服务端地址，这个参数需要强转成(struct sockaddr *)类型</li>\n<li>第三个参数是服务端地址长度</li>\n</ul>\n</li>\n<li><code>int listen(int sockfd, int backlog)</code><ul>\n<li>第一个参数是socket</li>\n<li>第二个参数是backlog, <a href=\"http://man7.org/linux/man-pages/man2/listen.2.html\" target=\"_blank\" rel=\"noopener\">关于backlog的解释</a></li>\n</ul>\n</li>\n<li><code>int accept(int sockfd, struct sockaddr * sockAddr, socklen_t * sockAddrLen)</code><ul>\n<li>第一个参数是服务端socket描述符</li>\n<li>第二个参数是传出参数，accept返回时传出客户端的地址和端口号</li>\n<li>第三个参数是传入-传出参数，传入的是服务端提供的clientAddr缓冲区的大小，传出的是客户端地址结构的实际长度</li>\n<li>出错返回-1</li>\n</ul>\n</li>\n<li><code>ssize_t recv(int sockfd, const void *buff, size_t nbytes, int flags)</code><ul>\n<li>第一个参数是客户端socket描述符</li>\n<li>第二个参数是接收缓冲区</li>\n<li>第三个参数是接收数据的长度??存疑</li>\n<li>第四个参数一般设置为0</li>\n</ul>\n</li>\n<li><code>ssize_t    send(int sockfd, const void * buff, size_t nbytes, int flags)</code><ul>\n<li>第一个参数是客户端socket描述符</li>\n<li>第二个参数是发送缓冲区</li>\n<li>第三个参数是发送数据的长度??存疑</li>\n<li>第四个参数一般设置为0</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"代码示例\"><a href=\"#代码示例\" class=\"headerlink\" title=\"代码示例\"></a>代码示例</h2><ul>\n<li>服务端程序<code>server.c</code></li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;errno.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netdb.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netinet/in.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;arpa/inet.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SERVER_PORT 5555</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> serverSocket, clientSocket;<span class=\"comment\">//声明服务端和客户端socket</span></span><br><span class=\"line\">  serverSocket = socket(AF_INET, SOCK_STREAM, <span class=\"number\">0</span>);<span class=\"comment\">//调用socket，获得服务端socket</span></span><br><span class=\"line\">  <span class=\"comment\">//异常检测</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(serverSocket &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    perror(<span class=\"string\">\"server socket error\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">serverAddr</span>;</span><span class=\"comment\">//声明服务端地址结构</span></span><br><span class=\"line\">  bzero(&amp;serverAddr, <span class=\"keyword\">sizeof</span>(serverAddr));<span class=\"comment\">//服务端地址结构填充</span></span><br><span class=\"line\">  serverAddr.sin_family = AF_INET;<span class=\"comment\">//设置地址类型</span></span><br><span class=\"line\">  serverAddr.sin_port = htons(SERVER_PORT);<span class=\"comment\">//设置地址端口,将端口转换成网络字节序</span></span><br><span class=\"line\">  serverAddr.sin_addr.s_addr = htonl(INADDR_ANY);<span class=\"comment\">//INADDR_ANY代表0.0.0.0,转换成网络字节序</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">clientAddr</span>;</span><span class=\"comment\">//声明客户端地址结构</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> clientAddrLen = <span class=\"keyword\">sizeof</span>(clientAddr);<span class=\"comment\">//客户端地址长度</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> buffer[<span class=\"number\">200</span>];<span class=\"comment\">//读取数据用的缓冲区</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> dataSize;<span class=\"comment\">//客户端返回的字节数</span></span><br><span class=\"line\">  <span class=\"comment\">//调用bind,第二个参数要强转成(struct sockaddr *)类型</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> checkBind = bind(serverSocket, (struct sockaddr *)&amp;serverAddr, <span class=\"keyword\">sizeof</span>(serverAddr));</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(checkBind &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    perror(<span class=\"string\">\"server bind error\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> checkListen = listen(serverSocket, <span class=\"number\">5</span>);<span class=\"comment\">//第二个参数是backlog，一般设置到30以下</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(checkListen &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    perror(<span class=\"string\">\"server listen error\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//开始主循环，接收客户端请求并处理请求</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Listening on port: %d\\n\"</span>, SERVER_PORT);</span><br><span class=\"line\">    <span class=\"comment\">//调用accept函数，进程进入阻塞状态</span></span><br><span class=\"line\">    <span class=\"comment\">//accept返回客户端socket的文件描述符</span></span><br><span class=\"line\">    <span class=\"comment\">//clientAddr是传出参数，accept返回时传出客户端的地址和端口号</span></span><br><span class=\"line\">    <span class=\"comment\">//clientAddrLen是传入-传出参数，传入的是服务端提供的clientAddr缓冲区的大小，传出的是客户端地址结构的实际长度</span></span><br><span class=\"line\">    <span class=\"comment\">//出错返回-1</span></span><br><span class=\"line\">    clientSocket = accept(serverSocket, (struct sockaddr *)&amp;clientAddr, (<span class=\"keyword\">socklen_t</span>*)&amp;clientAddrLen);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(clientSocket &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">      perror(<span class=\"string\">\"server accept error\"</span>);</span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//打印出客户端的ip和端口</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"client ip: %s\\n\"</span>, inet_ntoa(clientAddr.sin_addr));</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"client port: %d\\n\"</span>, htons(clientAddr.sin_port));</span><br><span class=\"line\">    <span class=\"comment\">//开始读取客户端数据...</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">      dataSize = recv(clientSocket, buffer, <span class=\"number\">1024</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(dataSize &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        perror(<span class=\"string\">\"server recv error\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">      &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(dataSize == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//read返回0， 可关闭连接</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">printf</span>(<span class=\"string\">\"dataSize大小：(%d)\\n\"</span>, dataSize);</span><br><span class=\"line\">      buffer[dataSize] = <span class=\"string\">'\\0'</span>;<span class=\"comment\">//设置缓冲区结尾为\\0</span></span><br><span class=\"line\">      <span class=\"comment\">//如果客户端发送(quit\\r\\n)，结束传输数据，跳出循环</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(<span class=\"built_in\">strcmp</span>(buffer, <span class=\"string\">\"quit\\r\\n\"</span>) == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"built_in\">strcmp</span>(buffer, <span class=\"string\">\"quit\"</span>) == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d data received, data is: (%s)\\n\"</span>, dataSize, buffer);</span><br><span class=\"line\">      <span class=\"comment\">//把收到的数据发给客户端</span></span><br><span class=\"line\">      send(clientSocket, buffer, dataSize, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}